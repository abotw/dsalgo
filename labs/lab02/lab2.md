---
title: "Lab 2:"
layout: home
parent: Labs
---
# Lab2: 

## Q1: removeSubstring

利用串的基本运算，编写一个算法删除串S1中所有的S2子串。

要求如下：

1. 示例：`S1='abcabc'`，`S2='ab'`，执行后`S1='cc'`
2. S2不能是空串
3. 若S2不是S1的子串，需提示错误信息
4. 提交作业时需包括程序源码和运行结果截图（包含 自拟 测试用例）

### Solution

```cpp

```

## Q2

设计算法实现删除顺序表中多余重复元素。如：对于顺序表（1，2，3，1，3，4，3， 5），删除第四个元素 1 及第五、第七个元素 3。



## Q3

设计算法，实现在一个递增有序的顺序表的适当位置插入元素 x，使得该顺序表仍然 递增有序。分析算法的时间复杂度
























































`size_t` 和 `std::string::npos` 是 C++ 标准库中的概念，常用于字符串操作中。接下来我将详细解释它们的作用以及为什么在程序中需要使用它们。

### 1. `size_t`
**`size_t`** 是 C++ 标准库中定义的一种数据类型，主要用于表示非负的大小或索引。

#### 为什么要用 `size_t`？
- **数据类型的适用性**：`size_t` 是专门用来表示内存大小和数组、字符串等**容器**的索引的类型。它通常是一个**无符号整数类型**，适用于表示任何**正整数**，并且由于它的无符号性质，避免了负值带来的问题。
- **平台无关**：`size_t` 是平台无关的，它的具体大小根据操作系统和硬件的不同而变化。例如在32位系统上，它可能是4字节，而在64位系统上，它可能是8字节。通过使用 `size_t`，程序能够在不同的平台上高效、无错误地处理大小和索引。
- **find() 返回类型**：`std::string::find()` 函数返回 `size_t` 类型的值，表示子串首次出现的位置（索引）。因此，使用 `size_t` 来存储这个返回值是最合适的选择。

```cpp
size_t pos = S1.find(S2);
```
- 这里的 `pos` 代表 `S2` 在 `S1` 中首次出现的位置。由于这个值是非负的索引，`size_t` 是合适的类型。

### 2. `std::string::npos`
**`std::string::npos`** 是 `std::string` 类中定义的一个常量，用于表示一个特殊的值，通常表示“未找到”的情况。

#### 为什么要用 `std::string::npos`？
- **表示未找到的子串**：`std::string::find()` 函数在成功找到子串时，返回它的起始索引（`size_t` 类型），而如果没有找到子串，它会返回一个特殊的值：`std::string::npos`。这个值通常是 `size_t` 类型的最大值，比如在32位系统上可能是 `4294967295`，但你不需要关心它的具体数值，只需知道它表示“未找到”即可。
  
```cpp
if (pos == std::string::npos) {
    // Handle error: substring not found
}
```
- 这段代码检查 `S2` 是否在 `S1` 中找到了。如果 `find()` 返回 `std::string::npos`，表示 `S2` 不是 `S1` 的子串，因此触发错误处理逻辑。

### 总结
- **`size_t`**：用于表示字符串或数组的大小或索引，适用于返回非负整数值的函数，确保在处理内存大小、索引时没有负值问题。
- **`std::string::npos`**：用来表示“未找到”的特殊标志，常用于 `find()` 等字符串查找函数的返回值判断。

这两个元素是 C++ 标准库中处理字符串和其他容器时的常见工具，能够提高程序的可移植性和安全性。